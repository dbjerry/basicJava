package f_oop2;

public class InheritanceBasic {
	public static void main(String[] args) {
		/*
		
		1. 상속(~은 ~이다.)
			- 기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
			- 적은 양의 코드로 새로운 클래스를 작성할 수 있다.
			- 새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을
			키워드 'extends'와 함께 써주기만 하면 된다.
			
				class child extends parent {
				
				}
			
			- 상속해주는 클래스를 '조상클래스',
			상속받는 클래스를 '자손클래스'라고 한다.
				: 조상클래스 - 부모클래스, 상위클래스, 기반클래스
				: 자손클래스 - 자식클래스, 하위클래스, 파생된 클래스
			
			- 멤버만 상속된다.
			- 자손클래스의 멤버개수는 조상클래스보다 항상 같거나 많다.
		
		2. 포함(~은 ~을 포함하고 있다.)
			- 상속이외에 클래스를 재사용하는 방법이다.
			- 한 클래스의 멤버변수로 다른 클래스를 선언하는 방법이다.
			
		3. 단일상속
			- Java에서는 단일상속(두 개이상은 불가능)
			  class TVCR extends TV, VCR { //error, 2개의 부모클래스를 상속하려 시도함
			  
			  }
		
			- TV와 VCR에 동일명의 메서드가 있다면 어떤 것을 상속받을지 알 수 없다.
			  VCR의 메서드명을 바꾼다면 구분은 가능하나 이전에 사용했던 모든
			    부분에 대해 수정해주어야 한다.
		
			- 클래스간의 관계가 좀 더 명확해지므로 코드를 더욱 신뢰할 수 있다.
			
		4. Object클래스(모든 클래스의 조상)
			- 모든 클래스 상속계층도의 제일 위에 위치하는 조상 클래스이다.
			- 다른 클래스로부터 상속받지 않는 클래스들은 자동적으로 Object클래스를
			  상속받는다.
			  
			  class Tv extends Object {
			  
			  }
		
		5. 오버라이딩(override)
			- 조상 클래스로부터 상속받는 메서드를 재정의 하는 것.
			- 오버라이딩이 성립하기 위한 조건
			 : 선언부가 일치하면 된다.
			 : 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의
			  메서드와 이름이 같아야한다.
			  매개변수의 개수와 타입이 같아야 한다.
			  리턴타입도 같아야 한다.
			 : 조상 클래스의 메서드를 자손 클래스에서 오버라이딩 할 때
			  접근제어자를 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
			  예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
			  인스턴스 메서드를 클래스 메서드로 또는 그 반대로 할 수 없다.
			
		6. super.
			- 조상 클래스의 멤버와 자손 클래스의 멤버가 중복 정의되어 있어
			서로 구분해야 하는 경우 사용
			- 조상멤버와 자손의 멤버를 구별하는데 사용된다는 점을 제외하고는
			this. 과 근본적으로 같다.
			- static메서드에 사용할 수 없다.
			
		7. super() - 조상클래스의 생성자 호출
			- this()와 마찬가지로 super() 역시 생성자 호출이다.
			- this()는 같은 클래스의 다른 생성자 호출
			super()는 조상클래스의 생성자 호출
			- 생성자의 첫 줄에는 조상클래스의 생성자를 호출해야 한다.
			자손클래스의 멤버가 조상클래스의 멤버를 사용할 수 있음으로
			조상의 멤버들을 먼저 초기화해야 한다.
			
		8. 제어자
			- 클래스, 변수 또는 메서드의 선언부에 사용된다.
			- 접근제어자와 그외 제어자로 나누어진다.
			  : 접근제어자 => private, default, protected, public
			  : 그외 제어자 => static, final, abstract, native..등등
			- 접근제어자를 가장 왼쪽에 일반적으로 둔다.
			- static (클래스의, 공통적인)
			  : 멤버변수, 메서드, 초기화블럭
			  : static 멤버변수
			  	모든 인스턴스에서 공통적으로 사용
			  	인스턴스를 생성하지 않고 사용할 수 있다.
			  	클래스가 메모리에 로드될 때 같이 생성된다.
			  : static 메서드
			  	인스턴스를 생성하지 않고 호출이 가능한 메서드
			  	클래스메서드 내에서는 인스턴스 멤버들을 호출 할 수 없다.
			- final(마지막의, 변경할 수 없는)
			  : 변수에 사용시 값을 변경할 수 없는 상수가 된다.
			  : 메서드 사용시 오버라이딩 할 수 없다.
			  : 클래스에 사용시 다른 클래스의 조상이 될 수 없다.
			  
			- abstract(추상의, 미완성의)
			  : 메서드 사용시 구현부가 존재하지 않는 메서드이다.
			  //void method();
			  : 클래스에 사용시 추상메서드가 존재하는 클래스임을 알려준다.
			  
		9. 접근제어자
			- private : 같은 클래스 내에서 접근이 가능하다.
			- default : 같은 패키지 내에서만 접근이 가능하다.
			- protected : 같은 패키지 + 다른 패키지의 자손클래스
			- public : 접근제한이 없다.
			- 클래스에는 public, default만 사용 가능하다.
			- 메서드 및 멤버변수에는 전부 사용가능하다.
			
		10. 캡슐화
			- 접근제어자를 사용하는 이유
			  : 외부로부터 데이터를 보호하기 위해서
			  : 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해
			  
		11. 생성자의 접근 제어자
			- 인스턴스의 생성을 제한할 수 있다.
			- 생성자의 접근제어자를 private으로 지정
			  : 외부에서 생성자에 접근할 수 없으므로 인스턴스의 생성을 제한할 수 있다.
			  : 다른 클래스의 조상이 될 수 없다.
			  : 상속할 수 없는 클래스임을 알려주는 final을 추가하여 상속할 수 없는
			  클래스임을 알리는 것이 좋다.
		
		12. 다형성(polymorphism)
			- 여러가지 형태를 가질 수 있는 능력
			- 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있다.
				부모타입의 참조변수로 자손타입의 인스턴스를 참조할 수 '있다'.
				자손타입의 참조변수로 부모타입의 인스턴스를 참조할 수 '없다'.
		
		13. 참조변수의 형변환
			- 서로 상속관계에 있는 클래스에서만 형변환이 가능하다.
			- 자손타입 => 부모타입 (up-casting) : 형변환 생략이 가능
			- 부모타입 => 자손타입 (down-casting) : 형변환 생략이 불가능
			//Product pro = new NoteBook("jin",28); //부모는 자식을 참조할 수 있으나, 자식은 부모를 참조할 수 없다. & up-casting이며 생략이 가능
			//NoteBook jin* = (NoteBook)pro; //업캐스팅이 먼저 돼야 down-casting이 가능하다.(down-casting부터하면 밑에 써있음)
			///NoteBook note = (NoteBook)new Product("jin", 28);
			////down-casting은 up-casting이 된 후에 해야함. 바로 down-casting을 하면 컴파일시 에러는 안나오나, 실행시 터짐!!
			//Product upJin = jin*; //NoteBook타입(자식클라쓰)의 jin*을 Product타입(부모클라쓰)으로 up-casting(형변환 생략가능)
		
		14. instanceof 연산자
			- 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
			- 연산결과가 true라면 참조변수가 검사한 타입으로 형변환이 가능하다.
			- 클래스메서드는 클래스변수처럼 참조변수의 타입에 영향을 받는다.
			    참조변수의 타입에 영향을 받지 않는 것은 (오버라이드)인스턴스 메서드 뿐이다.
		
		15. 매개변수의 다형성
			- 참조변수의 다형적인 특징을 메서드의 매개변수에 활용할 수 있다.
		
		16. 여러객체배열 Vector
			- Product[] p = new Product[]{new NoteBook, new Tv2, new Dyson};
				: 배열을 사용할 경우 전체 크기를 한 번 정하면 확장 할 수 없다.
			- Vector
				: 이를 Vector클래스를 이용하여 해결할 수 있다.
				: 동적으로 크기가 관리되는 객체배열이라고 생각하면 된다.
				
			Vector() : 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다.
			add() : 객체를 추가한다.
			remove() : 객체를 삭제한다.
			isEmpty() : Vector가 비어있는지 확인한다. 비어있으면 true, 하나라도 있으면 false
			Object get(int index) : 해당번째 객체를 반환해준다. 어떤 객체든 반환하기 위해서 Object
			int size() : 저장된 객체의 '개수'를 반환한다.
		
		
		17. 추상클래스(abstract class)
			- 미완성된 클래스 : 미완성된 메서드를 포함하고 있다는 의미
			abstract class 클래스명{
			
			}
		
			- 추상메서드
				: 메서드는 선언부와 구현부로 이루어져 있다.
				: 선언부만 만들어지고 구현부는 작성되지 않은 메서드를 추상메서드라 한다.
			abstract void method();
		
			- 추상클래스를 상속받는 자손클래스는 오버라이딩(재정의)을 통해
			조상인 클래스의 추상메서드를 구현하여 추상클래스가 아닐 수 있다.
		
		
		18. 인터페이스(interface)
			- 일종의 추상클래스이지만 추상메서드, 상수만 사용할 수 있다.
			- 인터페이스 작성
			interface 인터페이스명{
				public static final 변수타입 상수명 = 값;
				public abstract 반환타입 메서드명((매개변수));
			}
			  : 모든 멤버변수(상수)는 public static final이어야 한다.(생략가능)
			  : 모든 메서드는 public abstract이어야 한다.(생략가능)
			
			- 인터페이스의 상속
				: 인터페이스는 인터페이스만 상속 받을 수 있다.
				: 클래스와 달리 다중상속이 가능하다.(구현부가 없어서 가능)
				: 인터페이스는 클래스와 달리 Object클래스와 같은 최고 조상이 없다.
				
			- 인터페이스의 구현(추상클래스와 비슷하다.)
				: 자체로는 인스턴스를 생성할 수 없다.
				: 자신이 정의된 추상메서드의 몸통(구현부)을 만들어주는 클래스를 작성한다.
				: 클래스의 확장(extends), 인터페이스의 구현(implements) 클래스가 인터페이스를 구현할 때
				: 인터페이스의 일부 메서드만 구현했다면 그 클래스는 추상클래스가 된다.
				: 인터페이스명 ~able(~을 할 수 있는)
					IMemberService => IMemberServiceImpl
					
			- 인터페이스의 장점
				: 개발시간을 단축할 수 있다.(물론 PL의 역할이 정상적으로 이루어졌을 때)
				: 표준화가 가능하다.
				: 서로 관계가 없는 클래스들에게 관계를 맺어줄 수 있다.
				: 독립적인 프로그래밍이 가능하다.
				
				√ 7-26예제 필수적으로 해보기
				
			- 인터페이스의 이해
				: 클래스를 제공하는 쪽(provider)와 클래스를 사용하는 쪽(user)
				: 직접적인 관계를 간접적인 관계로 변경해 줄 수 있다.
				  A - I - B
				  
			- JDK1.8의 경우
				: default로 메서드에 구현부를 작성할 수 있다.
				: 하위에 있는 메서드가 무조건 구현해야 한다.
		
		19. 내부클래스(inner class)
			- 내부클래스란?
				: 클래스내에 선언된 클래스이다.
				: 서로 쉽게 접근할 수 있고 외부에서 볼 때 불필요한 클래스를 감춤으로
				복잡성을 줄일 수 있다.
			- 인스턴스클래스(instance class)
				: 외부클래스의 인스턴스멤버들과 관련된 작업을 한다.(인스턴스멤버변수와 메서드를 관리하는 클래스)
			- 스태틱 클래스(static class)
				: 외부클래스의 클래스멤버들과 관련된 작업을 수행한다.
			- 지역클래스(local class)
				: 외부클래스의 메서드나 초기화블럭 안에 선언되며, 선언된 영역 내에서만 사용할 수 있다.
			- 익명클래스(anonymous class)
				: 클래스의 선언과 객체의 생성을 동시에 진행하는 이름없는 클래스(1회용)
		
		*/
	}

}
